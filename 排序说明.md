# ID 排序说明

## 排序规则

两个页面（Badcase列表 和 流转状态）现在都按照 **ID 从新到旧（降序）** 排列。

### 排序逻辑

```typescript
// 提取ID中的数字部分进行比较（例如：BC0001 -> 1）
const numA = parseInt(a.id.replace(/\D/g, ''), 10);
const numB = parseInt(b.id.replace(/\D/g, ''), 10);
return numB - numA; // 降序：大的ID在前面（新的在前面）
```

### 示例

假设有以下 ID：
- BC0001
- BC0005
- BC0003
- BC0010
- BC0007

**排序后的顺序：**
1. BC0010 (最新)
2. BC0007
3. BC0005
4. BC0003
5. BC0001 (最旧)

## 应用场景

排序会在以下情况下自动应用：

### 1. 页面初始加载
当页面加载时，数据会自动按ID降序排列。

### 2. 数据更新时
- 新增 Badcase 后，新记录会出现在列表最前面
- 更新状态后，顺序保持不变（因为ID不变）
- 删除记录后，剩余记录保持降序排列

### 3. 搜索/筛选后
当使用搜索或筛选功能后，筛选出的结果也会按ID降序排列。

### 4. 重置筛选后
点击"重置"按钮后，显示所有数据并按ID降序排列。

## 两个页面的一致性

**Badcase列表** 和 **流转状态** 两个页面使用完全相同的排序逻辑：

```typescript
// BadcaseListPage.tsx 和 StatusFlowPage.tsx 都使用这个排序
const sortedList = [...badcaseList].sort((a, b) => {
  const numA = parseInt(a.id.replace(/\D/g, ''), 10);
  const numB = parseInt(b.id.replace(/\D/g, ''), 10);
  return numB - numA;
});
```

这确保了：
✅ 两个页面的数据顺序完全一致  
✅ 切换页面时，相同ID的记录在相同位置  
✅ 最新添加的记录始终在最前面  

## 技术实现

### 1. 初始加载排序
```typescript
useEffect(() => {
  const sortedList = [...badcaseList].sort((a, b) => {
    const numA = parseInt(a.id.replace(/\D/g, ''), 10);
    const numB = parseInt(b.id.replace(/\D/g, ''), 10);
    return numB - numA;
  });
  setDataSource(sortedList);
}, [badcaseList]);
```

### 2. 搜索时排序
```typescript
const handleSearch = () => {
  // ... 筛选逻辑 ...
  
  // 按ID降序排列
  filtered.sort((a, b) => {
    const numA = parseInt(a.id.replace(/\D/g, ''), 10);
    const numB = parseInt(b.id.replace(/\D/g, ''), 10);
    return numB - numA;
  });
  
  setDataSource(filtered);
};
```

### 3. 重置时排序
```typescript
const handleReset = () => {
  // ... 重置筛选条件 ...
  
  // 按ID降序排列
  const sortedList = [...badcaseList].sort((a, b) => {
    const numA = parseInt(a.id.replace(/\D/g, ''), 10);
    const numB = parseInt(b.id.replace(/\D/g, ''), 10);
    return numB - numA;
  });
  setDataSource(sortedList);
};
```

## ID 格式说明

当前系统的 ID 格式为：`BC + 4位数字`

示例：
- BC0001
- BC0002
- BC0010
- BC0100

**数字提取逻辑：**
- `a.id.replace(/\D/g, '')` - 移除所有非数字字符
- `parseInt(..., 10)` - 转换为十进制整数
- `BC0001` → `0001` → `1`
- `BC0010` → `0010` → `10`

这确保了即使ID格式改变，只要包含数字，排序逻辑仍然有效。

## 表格列的排序器

除了默认排序，表格列也支持手动排序：

### 提交日期列排序
```typescript
{
  title: '提交日期',
  dataIndex: 'date',
  sorter: (a, b) => new Date(a.date).getTime() - new Date(b.date).getTime(),
}
```

### 期望修复时间列排序
```typescript
{
  title: '期望修复时间',
  dataIndex: 'expectedFixDate',
  sorter: (a, b) => new Date(a.expectedFixDate).getTime() - new Date(b.expectedFixDate).getTime(),
}
```

用户可以点击列标题进行自定义排序，但默认情况下，数据始终按ID降序显示。

## 测试验证

### 测试步骤

1. **测试初始排序**
   - 打开 Badcase 列表页面
   - 观察 ID 列，确认从大到小排列
   - 切换到流转状态页面
   - 确认 ID 列顺序与 Badcase 列表一致

2. **测试新增后的排序**
   - 在 Badcase 列表新增一条记录
   - 确认新记录出现在列表最前面
   - 切换到流转状态页面
   - 确认新记录也在最前面

3. **测试搜索后的排序**
   - 在搜索框输入关键词
   - 点击搜索
   - 确认搜索结果也是按ID降序排列

4. **测试重置后的排序**
   - 设置一些筛选条件
   - 点击"重置"按钮
   - 确认所有数据按ID降序显示

5. **测试跨页面一致性**
   - 在 Badcase 列表页面记录前3条ID
   - 切换到流转状态页面
   - 确认前3条ID完全一致

### 预期结果

✅ 所有测试场景中，两个页面的 ID 顺序都是一致的  
✅ 最新的记录（ID最大）始终在最前面  
✅ 搜索、筛选、重置后排序不变  

---

**更新时间：** 2025-12-22  
**版本：** v2.1.0

